From 74391cf66fa1832bc62d735321b9e4075d7fe4f5 Mon Sep 17 00:00:00 2001
From: Alexandru Costache <alexandru@balena.io>
Date: Thu, 14 Oct 2021 14:42:52 +0200
Subject: [PATCH] Avoid hang at boot if pcie oscillator not present

Some custom carrier boards don't have pcie oscillator
and according to the shared logs this can cause a hang at boot.

The relevant log when this happens is:
    33800000.pcie: PCIe PLL lock timeout

Let's propagate this error to imx6_pcie_host_init
and bail out if pcie cannot be initialized on
custom carrier boards.

Upstream-status: Inappropriate [configuration]
Signed-off-by: Alexandru Costache <alexandru@balena.io>
---
 drivers/pci/controller/dwc/pci-imx6.c | 61 ++++++++++++++++++---------
 1 file changed, 41 insertions(+), 20 deletions(-)

diff --git a/drivers/pci/controller/dwc/pci-imx6.c b/drivers/pci/controller/dwc/pci-imx6.c
index c655d9de144e..08eec8792137 100644
--- a/drivers/pci/controller/dwc/pci-imx6.c
+++ b/drivers/pci/controller/dwc/pci-imx6.c
@@ -866,23 +866,29 @@ static int imx6_pcie_enable_ref_clk(struct imx6_pcie *imx6_pcie)
 	return ret;
 }
 
-static void imx7d_pcie_wait_for_phy_pll_lock(struct imx6_pcie *imx6_pcie)
+static int imx7d_pcie_wait_for_phy_pll_lock(struct imx6_pcie *imx6_pcie)
 {
 	u32 val;
 	struct device *dev = imx6_pcie->pci->dev;
+	int ret = 0;
 
 	if (regmap_read_poll_timeout(imx6_pcie->iomuxc_gpr,
 				     IOMUXC_GPR22, val,
 				     val & IMX7D_GPR22_PCIE_PHY_PLL_LOCKED,
 				     PHY_PLL_LOCK_WAIT_USLEEP_MAX,
-				     PHY_PLL_LOCK_WAIT_TIMEOUT))
+				     PHY_PLL_LOCK_WAIT_TIMEOUT)) {
 		dev_err(dev, "PCIe PLL lock timeout\n");
+		ret = -ENODEV;
+	}
+
+	return ret;
 }
-static void imx8_pcie_wait_for_phy_pll_lock(struct imx6_pcie *imx6_pcie)
+static int imx8_pcie_wait_for_phy_pll_lock(struct imx6_pcie *imx6_pcie)
 {
 	u32 val, retries = 0, tmp = 0, orig = 0;
 	struct dw_pcie *pci = imx6_pcie->pci;
 	struct device *dev = pci->dev;
+	int ret = 0;
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX8MP:
@@ -946,10 +952,14 @@ static void imx8_pcie_wait_for_phy_pll_lock(struct imx6_pcie *imx6_pcie)
 		break;
 	}
 
-	if (retries >= PHY_PLL_LOCK_WAIT_MAX_RETRIES)
-		dev_err(dev, "PCIe PLL lock timeout\n");
+	if (retries >= PHY_PLL_LOCK_WAIT_MAX_RETRIES) {
+		dev_err(dev, "iMX8 PCIe PLL lock timeout\n");
+		ret = -ENODEV;
+	}
 	else
 		dev_info(dev, "PCIe PLL locked after %d us.\n", retries * 10);
+
+	return ret;
 }
 
 static void imx6_pcie_clk_enable(struct imx6_pcie *imx6_pcie)
@@ -1142,19 +1152,18 @@ static void imx6_pcie_assert_core_reset(struct imx6_pcie *imx6_pcie)
 	}
 }
 
-static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
+static int imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 {
 	struct dw_pcie *pci = imx6_pcie->pci;
 	struct device *dev = pci->dev;
-	int ret, i;
+	int i, ret = 0;
 	u32 val, tmp;
-
 	if (imx6_pcie->vpcie && !regulator_is_enabled(imx6_pcie->vpcie)) {
 		ret = regulator_enable(imx6_pcie->vpcie);
 		if (ret) {
 			dev_err(dev, "failed to enable vpcie regulator: %d\n",
 				ret);
-			return;
+			return ret;
 		}
 	}
 
@@ -1206,13 +1215,16 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 			dev_err(dev, "ERROR PM_REQ_CORE_RST is still set.\n");
 
 		/* wait for phy pll lock firstly. */
-		imx8_pcie_wait_for_phy_pll_lock(imx6_pcie);
+		ret = imx8_pcie_wait_for_phy_pll_lock(imx6_pcie);
 		break;
 	case IMX8MQ:
 	case IMX8MM:
 		reset_control_deassert(imx6_pcie->pciephy_reset);
-
-		imx8_pcie_wait_for_phy_pll_lock(imx6_pcie);
+		ret = imx8_pcie_wait_for_phy_pll_lock(imx6_pcie);
+		if (0 > ret) {
+			dev_err(dev, "imx8_pcie_wait_for_phy_pll_lock failed, pcie oscillator most likely missing on carrier board. Bail out to avoid hang at boot.\n");
+			return ret;
+		}
 		/*
 		 * Set the over ride low and enabled
 		 * make sure that REF_CLK is turned on.
@@ -1224,12 +1236,12 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
 				   IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN,
 				   IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN);
-
 		if (imx6_pcie->drvdata->flags & IMX6_PCIE_FLAG_SUPPORTS_L1SS) {
 			/*
 			 * Configure the CLK_REQ# high, let the L1SS
 			 * automatically controlled by HW later.
 			 */
+			/* Following call might hang if imx8_pcie_wait_for_phy_pll_lock fails */
 			reset_control_deassert(imx6_pcie->clkreq_reset);
 			/*
 			 * Configure the L1 latency of rc to less than 64us
@@ -1289,7 +1301,7 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 		reset_control_deassert(imx6_pcie->pciephy_reset);
 		udelay(10);
 
-		imx8_pcie_wait_for_phy_pll_lock(imx6_pcie);
+		ret = imx8_pcie_wait_for_phy_pll_lock(imx6_pcie);
 		break;
 	case IMX7D:
 		reset_control_deassert(imx6_pcie->pciephy_reset);
@@ -1313,7 +1325,7 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 			dev_warn(dev, "Unable to apply ERR010728 workaround. DT missing fsl,imx7d-pcie-phy phandle ?\n");
 		}
 
-		imx7d_pcie_wait_for_phy_pll_lock(imx6_pcie);
+		ret = imx7d_pcie_wait_for_phy_pll_lock(imx6_pcie);
 		break;
 	case IMX6SX:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR5,
@@ -1329,7 +1341,7 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 		break;
 	}
 
-	return;
+	return ret;
 }
 
 static void imx6_pcie_configure_type(struct imx6_pcie *imx6_pcie)
@@ -1863,14 +1875,21 @@ static void pci_imx_set_msi_en(struct pcie_port *pp)
 static int imx6_pcie_host_init(struct pcie_port *pp)
 {
 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct device *dev = pci->dev;
 	struct imx6_pcie *imx6_pcie = to_imx6_pcie(pci);
+	int ret;
 
 	if (gpio_is_valid(imx6_pcie->dis_gpio))
 		gpio_set_value_cansleep(imx6_pcie->dis_gpio, 1);
 
 	imx6_pcie_assert_core_reset(imx6_pcie);
 	imx6_pcie_init_phy(imx6_pcie);
-	imx6_pcie_deassert_core_reset(imx6_pcie);
+	ret = imx6_pcie_deassert_core_reset(imx6_pcie);
+	dev_info(dev, "imx6_pcie_host_init: imx6_pcie_deassert_core_reset ret: %d\n", ret);
+	if (0 > ret) {
+		dev_err(dev, "imx6_pcie_host_init failed: %d.\n", ret);
+		return ret;
+	}
 	imx6_setup_phy_mpll(imx6_pcie);
 	if (!(IS_ENABLED(CONFIG_EP_MODE_IN_EP_RC_SYS)
 			&& (imx6_pcie->hard_wired == 0))) {
@@ -2333,12 +2352,12 @@ static int imx6_pcie_suspend_noirq(struct device *dev)
 
 static int imx6_pcie_resume_noirq(struct device *dev)
 {
-	int ret;
+	int ret = 0;
 	struct imx6_pcie *imx6_pcie = dev_get_drvdata(dev);
 	struct pcie_port *pp = &imx6_pcie->pci->pp;
 
 	if (!(imx6_pcie->drvdata->flags & IMX6_PCIE_FLAG_SUPPORTS_SUSPEND))
-		return 0;
+		return ret;
 	if (unlikely(imx6_pcie->drvdata->variant == IMX6Q)) {
 		/*
 		 * L2 can exit by 'reset' or Inband beacon (from remote EP)
@@ -2351,7 +2370,9 @@ static int imx6_pcie_resume_noirq(struct device *dev)
 	} else {
 		imx6_pcie_assert_core_reset(imx6_pcie);
 		imx6_pcie_init_phy(imx6_pcie);
-		imx6_pcie_deassert_core_reset(imx6_pcie);
+		ret = imx6_pcie_deassert_core_reset(imx6_pcie);
+		if (0 != ret)
+			dev_info(dev, "imx6_pcie_resume_noirq - ret %d", ret);
 		dw_pcie_setup_rc(pp);
 		pci_imx_set_msi_en(pp);
 
-- 
2.17.1

